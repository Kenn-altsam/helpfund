from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
import traceback
import uuid
import httpx
import os
from typing import Optional
from dotenv import load_dotenv

load_dotenv()

from .models import ChatRequest, ChatResponse, CompanyCharityRequest, CompanyCharityResponse
from .assistant_creator import handle_conversation_with_context
from ..core.database import get_db
from ..auth.models import User
from ..auth.dependencies import get_current_user
from ..chats import service as chat_service

router = APIRouter(prefix="/ai", tags=["AI Conversation"])


@router.post("/chat-assistant", response_model=ChatResponse)
async def handle_chat_with_assistant(
    request: ChatRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Handle an AI conversation turn using Gemini API.
    - Uses Gemini for text generation.
    - Persists chat history in the database.
    """
    import time
    start_time = time.time()
    import uuid
    import os
    from ..chats import service as chat_service

    print(f"üí¨ [CHAT_ASSISTANT] New chat request from user {current_user.id}")
    print(f"üìù [CHAT_ASSISTANT] Input length: {len(request.user_input)} characters")

    if not request.user_input.strip():
        print(f"‚ùå [CHAT_ASSISTANT] Empty input rejected")
        raise HTTPException(status_code=400, detail="User input cannot be empty")

    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    if not GEMINI_API_KEY:
        raise HTTPException(status_code=500, detail="Gemini API key is not configured.")

    db_chat_id: Optional[uuid.UUID] = None
    if request.chat_id:
        try:
            db_chat_id = uuid.UUID(request.chat_id)
            print(f"üîó [CHAT_ASSISTANT] Using existing chat ID: {db_chat_id}")
        except ValueError:
            print(f"‚ùå [CHAT_ASSISTANT] Invalid chat_id format: {request.chat_id}")
            raise HTTPException(status_code=400, detail="Invalid chat_id format. Must be a UUID.")
    else:
        print(f"üÜï [CHAT_ASSISTANT] Creating new chat session")

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è prompt
    history = request.history or []
    prompt_parts = []
    for msg in history:
        role = msg.get("role", "user")
        content = msg.get("content", "")
        if role == "user":
            prompt_parts.append(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {content}")
        elif role == "assistant":
            prompt_parts.append(f"–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç: {content}")
    prompt_parts.append(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {request.user_input}")
    prompt = "\n".join(prompt_parts)

    gemini_url = f"https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key={GEMINI_API_KEY}"
    gemini_payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    print(f"ü§ñ [CHAT_ASSISTANT] Sending request to Gemini API...")
    print(f"üìä [CHAT_ASSISTANT] Prompt length: {len(prompt)} characters")

    import httpx
    try:
        async with httpx.AsyncClient() as client:
            gemini_start_time = time.time()
            gemini_res = await client.post(gemini_url, json=gemini_payload)
            gemini_res.raise_for_status()
            g_data = gemini_res.json()
            gemini_duration = time.time() - gemini_start_time
            print(f"‚úÖ [CHAT_ASSISTANT] Gemini API response received in {gemini_duration:.2f}s")
    except httpx.RequestError as e:
        print(f"‚ùå [CHAT_ASSISTANT] Gemini API error: {str(e)}")
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Gemini API.")
    except httpx.HTTPStatusError as e:
        print(f"‚ùå [CHAT_ASSISTANT] Gemini API HTTP error {e.response.status_code}: {str(e)}")
        raise HTTPException(status_code=500, detail="Gemini API –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Ç–≤–µ—Ç
    try:
        answer = g_data["candidates"][0]["content"]["parts"][0]["text"]
        answer_length = len(answer)
        print(f"üìù [CHAT_ASSISTANT] Gemini answer extracted - length: {answer_length} characters")
    except (KeyError, IndexError) as e:
        print(f"‚ö†Ô∏è [CHAT_ASSISTANT] Failed to extract answer from Gemini response: {str(e)}")
        raise HTTPException(status_code=500, detail="–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç Gemini.")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –±–∞–∑—É (–µ—Å–ª–∏ –µ—Å—Ç—å chat_id)
    updated_history = history + [{"role": "user", "content": request.user_input}, {"role": "assistant", "content": answer}]
    if db_chat_id:
        chat_service.create_message(db, chat_id=db_chat_id, content=request.user_input, role="user")
        chat_service.create_message(db, chat_id=db_chat_id, content=answer, role="assistant")
    # –ï—Å–ª–∏ –Ω–µ—Ç chat_id, –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

    total_duration = time.time() - start_time
    print(f"‚úÖ [CHAT_ASSISTANT] Successfully processed chat in {total_duration:.2f}s")

    return ChatResponse(
        message=answer,
        companies=[],
        updated_history=updated_history,
        assistant_id=None,
        chat_id=str(db_chat_id) if db_chat_id else None,
        openai_thread_id=None
    )


@router.post("/charity-research", response_model=CompanyCharityResponse)
async def get_company_charity_info(
    request: CompanyCharityRequest,
    current_user = Depends(get_current_user)
):
    """
    Research company's charity involvement using Google Search and Gemini AI.
    Searches for information about company's charitable activities without storing in database.
    """
    import time
    start_time = time.time()
    
    print(f"üîç [CHARITY_RESEARCH] Starting research for company: '{request.company_name}'")
    print(f"üë§ [CHARITY_RESEARCH] Requested by user ID: {current_user.id}")
    
    try:
        # Get API keys from environment
        GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
        SEARCH_ENGINE_ID = os.getenv("GOOGLE_SEARCH_ENGINE_ID")
        GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
        
        print(f"üîë [CHARITY_RESEARCH] API keys status - Google: {'‚úì' if GOOGLE_API_KEY else '‚úó'}, Search Engine: {'‚úì' if SEARCH_ENGINE_ID else '‚úó'}, Gemini: {'‚úì' if GEMINI_API_KEY else '‚úó'}")
        
        if not all([GOOGLE_API_KEY, SEARCH_ENGINE_ID, GEMINI_API_KEY]):
            print(f"‚ùå [CHARITY_RESEARCH] Missing API keys - cannot proceed")
            return CompanyCharityResponse(
                status="error",
                answer="–°–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
            )
        
        # Search for charity information about the company
        query = f"{request.company_name} –±–ª–∞–≥–æ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å OR charity OR —Å–ø–æ–Ω—Å–æ—Ä—Å—Ç–≤–æ OR donation"
        search_url = (
            f"https://www.googleapis.com/customsearch/v1?q={query}"
            f"&key={GOOGLE_API_KEY}&cx={SEARCH_ENGINE_ID}"
        )
        
        print(f"üîç [CHARITY_RESEARCH] Google search query: '{query}'")
        print(f"üåê [CHARITY_RESEARCH] Sending request to Google Custom Search API...")

        async with httpx.AsyncClient() as client:
            try:
                google_start_time = time.time()
                g_res = await client.get(search_url)
                g_res.raise_for_status()
                search_data = g_res.json()
                items = search_data.get("items", [])[:5]
                google_duration = time.time() - google_start_time
                print(f"‚úÖ [CHARITY_RESEARCH] Google Search completed in {google_duration:.2f}s - found {len(items)} results")
            except httpx.RequestError as e:
                print(f"‚ùå [CHARITY_RESEARCH] Google Search API error: {str(e)}")
                return CompanyCharityResponse(
                    status="error",
                    answer="–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–º–ø–∞–Ω–∏–∏ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ –ø–æ–∏—Å–∫–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ."
                )
            except httpx.HTTPStatusError as e:
                print(f"‚ùå [CHARITY_RESEARCH] Google Search HTTP error {e.response.status_code}: {str(e)}")
                return CompanyCharityResponse(
                    status="error",
                    answer="–ü–æ–∏—Å–∫–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )

        # Extract links and snippets
        links = [item.get("link", "") for item in items]
        snippets = [item.get("snippet", "") for item in items]
        
        print(f"üìã [CHARITY_RESEARCH] Extracted {len(links)} links and {len(snippets)} snippets")
        if links:
            print(f"üîó [CHARITY_RESEARCH] Top search results domains: {', '.join([link.split('/')[2] if '/' in link else link for link in links[:3]])}")

        # Check if we have enough data to proceed
        if not snippets or not any(snippets):
            print(f"‚ö†Ô∏è [CHARITY_RESEARCH] No search results found for company '{request.company_name}'")
            return CompanyCharityResponse(
                status="warning",
                answer=f"–î–∞–Ω–Ω—ã—Ö –æ –±–ª–∞–≥–æ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ–π –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–æ–º–ø–∞–Ω–∏–∏ '{request.company_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö."
            )

        # Create summary text for Gemini
        text_summary = "\n".join(snippets)
        summary_length = len(text_summary)
        print(f"üìù [CHARITY_RESEARCH] Created summary text with {summary_length} characters for Gemini analysis")
        
        # Create search links for sources
        search_links = "\n".join(f"- {url}" for url in links)
        
        # Create prompt for Gemini
        prompt = f"""
        –ö–æ–º–ø–∞–Ω–∏—è: {request.company_name}

        –ù–∞–π–¥–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—á–∞—Å—Ç–∏–∏ —ç—Ç–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ –≤ –±–ª–∞–≥–æ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Å–ø–æ–Ω—Å–æ—Ä—Å—Ç–≤–µ –∏–ª–∏ –ø–æ–∂–µ—Ä—Ç–≤–æ–≤–∞–Ω–∏—è—Ö. –ò—Å–ø–æ–ª—å–∑—É–π –æ–ø–∏—Å–∞–Ω–∏—è –∏ —Å—Å—ã–ª–∫–∏ –Ω–∏–∂–µ.

        –û–ø–∏—Å–∞–Ω–∏–µ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞:
        {text_summary}

        –°—Å—ã–ª–∫–∏ –Ω–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∏:
        {search_links}

        –û—Ç–≤–µ—Ç—å –∫—Ä–∞—Ç–∫–æ. –£–∫–∞–∂–∏, —É—á–∞—Å—Ç–≤–æ–≤–∞–ª–∞ –ª–∏ –∫–æ–º–ø–∞–Ω–∏—è –≤ –±–ª–∞–≥–æ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, –∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—Ü–∏—Ç–∏—Ä—É–π —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫ —Å URL –≤ –æ—Ç–≤–µ—Ç–µ.
        –ï—Å–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ ‚Äî —Ç–∞–∫ –∏ —Å–∫–∞–∂–∏.
        """

        # Send request to Gemini API
        gemini_url = f"https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key={GEMINI_API_KEY}"

        gemini_payload = {
            "contents": [{"parts": [{"text": prompt}]}]
        }
        
        print(f"ü§ñ [CHARITY_RESEARCH] Sending analysis request to Gemini 2.0 Flash API...")
        print(f"üìä [CHARITY_RESEARCH] Prompt length: {len(prompt)} characters")

        async with httpx.AsyncClient() as client:
            try:
                gemini_start_time = time.time()
                gemini_res = await client.post(gemini_url, json=gemini_payload)
                gemini_res.raise_for_status()
                g_data = gemini_res.json()
                gemini_duration = time.time() - gemini_start_time
                print(f"‚úÖ [CHARITY_RESEARCH] Gemini API response received in {gemini_duration:.2f}s")
            except httpx.RequestError as e:
                print(f"‚ùå [CHARITY_RESEARCH] Gemini API error: {str(e)}")
                return CompanyCharityResponse(
                    status="error",
                    answer="–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é. –ü—Ä–æ–±–ª–µ–º–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ AI —Å–µ—Ä–≤–∏—Å—É."
                )
            except httpx.HTTPStatusError as e:
                print(f"‚ùå [CHARITY_RESEARCH] Gemini API HTTP error {e.response.status_code}: {str(e)}")
                return CompanyCharityResponse(
                    status="error",
                    answer="AI —Å–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )

        # Extract answer from Gemini response
        try:
            answer = g_data["candidates"][0]["content"]["parts"][0]["text"]
            answer_length = len(answer)
            print(f"üìù [CHARITY_RESEARCH] Gemini analysis extracted - length: {answer_length} characters")
            
            # Validate that we got a meaningful response
            if not answer or len(answer.strip()) < 10:
                print(f"‚ö†Ô∏è [CHARITY_RESEARCH] Gemini returned empty or too short response")
                return CompanyCharityResponse(
                    status="warning",
                    answer=f"–ö–æ–º–ø–∞–Ω–∏—è '{request.company_name}' –º–æ–≥–ª–∞ —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –±–ª–∞–≥–æ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, –Ω–æ –¥–æ—Å—Ç–æ–≤–µ—Ä–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
                )
                
        except (KeyError, IndexError) as e:
            print(f"‚ö†Ô∏è [CHARITY_RESEARCH] Failed to extract answer from Gemini response: {str(e)}")
            return CompanyCharityResponse(
                status="error",
                answer="–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç AI. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )

        total_duration = time.time() - start_time
        print(f"‚úÖ [CHARITY_RESEARCH] Successfully completed analysis for '{request.company_name}' in {total_duration:.2f}s")
        print(f"üìä [CHARITY_RESEARCH] Final response size: {len(answer)} characters")
        
        return CompanyCharityResponse(
            status="success",
            answer=answer
        )

    except Exception as e:
        total_duration = time.time() - start_time
        print(f"‚ùå [CHARITY_RESEARCH] Unexpected error analyzing charity info for '{request.company_name}' after {total_duration:.2f}s: {str(e)}")
        traceback.print_exc()
        return CompanyCharityResponse(
            status="error",
            answer="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        ) 