"""
KGD Tax Data Importer

This script imports tax data from CSV files (generated by kgd_tax_parser.py) 
into the PostgreSQL database, updating the tax columns in the companies table.

Features:
- Batch processing for better performance
- Upsert operations (update if exists, skip if not)
- Data validation and cleaning
- Progress tracking and logging
- Error handling and reporting

Usage:
    python parser/kgd_data_importer.py
    
Database Schema:
    The script expects the following columns in the companies table:
    - annual_tax_paid (FLOAT) - for the most recent year
    - tax_2020 (FLOAT)
    - tax_2021 (FLOAT)
    - tax_2022 (FLOAT)
    - tax_2023 (FLOAT)
    - tax_2024 (FLOAT)
    - tax_2025 (FLOAT)
    - last_tax_update (DATE)
"""

import asyncio
import csv
import os
import sys
from datetime import datetime
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import asyncpg
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
BASE_DIR = Path(__file__).parent
KGD_DATA_DIR = BASE_DIR / "kgd_data"
TAX_DATA_CSV = KGD_DATA_DIR / "company_tax_data.csv"

# Database configuration
DATABASE_URL = os.getenv(
    "DATABASE_URL", 
    "postgresql://user:password@localhost:5432/Ayala_database"
)

# Logging configuration
IMPORT_LOG_CSV = KGD_DATA_DIR / "import_log.csv"
IMPORT_ERRORS_CSV = KGD_DATA_DIR / "import_errors.csv"

LOG_FIELDNAMES = [
    "import_date",
    "total_records",
    "successful_updates",
    "failed_updates",
    "skipped_records",
    "notes"
]

ERROR_FIELDNAMES = [
    "bin",
    "company_name",
    "error_type",
    "error_message",
    "import_date"
]


class KGDDataImporter:
    def __init__(self, database_url: str = DATABASE_URL):
        self.database_url = database_url
        self.connection = None
        
    async def connect(self):
        """Connect to PostgreSQL database"""
        try:
            self.connection = await asyncpg.connect(self.database_url)
            print("‚úÖ Connected to database")
        except Exception as e:
            print(f"‚ùå Failed to connect to database: {e}")
            raise
    
    async def disconnect(self):
        """Disconnect from database"""
        if self.connection:
            await self.connection.close()
            print("üîå Disconnected from database")
    
    async def ensure_tax_columns_exist(self):
        """Ensure tax columns exist in companies table"""
        try:
            # Check if tax columns exist
            query = """
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'companies' 
            AND column_name IN ('tax_2020', 'tax_2021', 'tax_2022', 'tax_2023', 'tax_2024', 'tax_2025')
            """
            
            existing_columns = await self.connection.fetch(query)
            existing_column_names = {row['column_name'] for row in existing_columns}
            
            # Define required columns
            required_columns = {
                'tax_2020': 'FLOAT',
                'tax_2021': 'FLOAT', 
                'tax_2022': 'FLOAT',
                'tax_2023': 'FLOAT',
                'tax_2024': 'FLOAT',
                'tax_2025': 'FLOAT'
            }
            
            # Add missing columns
            for column_name, column_type in required_columns.items():
                if column_name not in existing_column_names:
                    alter_query = f"""
                    ALTER TABLE companies 
                    ADD COLUMN IF NOT EXISTS {column_name} {column_type}
                    """
                    await self.connection.execute(alter_query)
                    print(f"‚ûï Added column: {column_name}")
            
            print("‚úÖ Tax columns verified/created")
            
        except Exception as e:
            print(f"‚ùå Error ensuring tax columns exist: {e}")
            raise
    
    def clean_tax_amount(self, amount: str) -> Optional[float]:
        """Clean and convert tax amount to float"""
        if not amount or amount.strip() == "":
            return None
            
        try:
            # Remove any non-numeric characters except digits, commas, dots, and minus
            cleaned = amount.strip().replace(" ", "").replace(",", "")
            
            # Handle empty or invalid values
            if not cleaned or cleaned in ['-', '.', '0', '0.0']:
                return None
            
            # Convert to float
            value = float(cleaned)
            
            # Return None for zero or negative values (assuming they're not meaningful)
            if value <= 0:
                return None
                
            return value
            
        except (ValueError, TypeError, InvalidOperation):
            return None
    
    def get_most_recent_tax(self, tax_data: Dict[str, Optional[float]]) -> Optional[float]:
        """Get the most recent non-null tax amount"""
        # Check years in reverse order (most recent first)
        for year in ['2025', '2024', '2023', '2022', '2021', '2020']:
            tax_key = f'tax_{year}'
            if tax_key in tax_data and tax_data[tax_key] is not None:
                return tax_data[tax_key]
        return None
    
    async def load_csv_data(self, csv_file: Path) -> List[Dict]:
        """Load tax data from CSV file"""
        data = []
        
        if not csv_file.exists():
            print(f"‚ùå CSV file not found: {csv_file}")
            return data
        
        try:
            with open(csv_file, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    # Clean and validate data
                    cleaned_row = {
                        'bin': row.get('bin', '').strip(),
                        'company_name': row.get('company_name', '').strip(),
                        'search_date': row.get('search_date', ''),
                        'tax_2020': self.clean_tax_amount(row.get('tax_2020', '')),
                        'tax_2021': self.clean_tax_amount(row.get('tax_2021', '')),
                        'tax_2022': self.clean_tax_amount(row.get('tax_2022', '')),
                        'tax_2023': self.clean_tax_amount(row.get('tax_2023', '')),
                        'tax_2024': self.clean_tax_amount(row.get('tax_2024', '')),
                        'tax_2025': self.clean_tax_amount(row.get('tax_2025', ''))
                    }
                    
                    # Only include rows with valid BIN
                    if cleaned_row['bin']:
                        data.append(cleaned_row)
            
            print(f"üìù Loaded {len(data)} records from {csv_file}")
            return data
            
        except Exception as e:
            print(f"‚ùå Error loading CSV data: {e}")
            return []
    
    async def update_company_tax_data(self, tax_data: Dict) -> Tuple[bool, str]:
        """Update tax data for a single company"""
        try:
            bin_number = tax_data['bin']
            
            # Check if company exists
            check_query = "SELECT id FROM companies WHERE bin = $1"
            company = await self.connection.fetchrow(check_query, bin_number)
            
            if not company:
                return False, f"Company with BIN {bin_number} not found"
            
            # Get the most recent tax amount for annual_tax_paid
            most_recent_tax = self.get_most_recent_tax(tax_data)
            
            # Prepare update query
            update_query = """
            UPDATE companies 
            SET 
                tax_2020 = $2,
                tax_2021 = $3,
                tax_2022 = $4,
                tax_2023 = $5,
                tax_2024 = $6,
                tax_2025 = $7,
                annual_tax_paid = $8,
                last_tax_update = $9,
                updated_at = CURRENT_TIMESTAMP
            WHERE bin = $1
            """
            
            await self.connection.execute(
                update_query,
                bin_number,
                tax_data['tax_2020'],
                tax_data['tax_2021'],
                tax_data['tax_2022'],
                tax_data['tax_2023'],
                tax_data['tax_2024'],
                tax_data['tax_2025'],
                most_recent_tax,
                datetime.now().date()
            )
            
            return True, "Success"
            
        except Exception as e:
            return False, str(e)
    
    async def batch_update_companies(self, tax_data_list: List[Dict], batch_size: int = 50) -> Dict[str, int]:
        """Update multiple companies in batches"""
        total = len(tax_data_list)
        successful = 0
        failed = 0
        skipped = 0
        
        print(f"üöÄ Starting batch update of {total} companies...")
        
        # Process in batches
        for i in range(0, total, batch_size):
            batch = tax_data_list[i:i+batch_size]
            batch_num = (i // batch_size) + 1
            total_batches = (total + batch_size - 1) // batch_size
            
            print(f"üì¶ Processing batch {batch_num}/{total_batches} ({len(batch)} records)")
            
            for j, tax_data in enumerate(batch):
                bin_number = tax_data['bin']
                company_name = tax_data['company_name']
                
                # Check if there's any tax data to update
                has_tax_data = any(
                    tax_data[f'tax_{year}'] is not None 
                    for year in ['2020', '2021', '2022', '2023', '2024', '2025']
                )
                
                if not has_tax_data:
                    print(f"‚è≠Ô∏è  Skipping {bin_number} - no tax data")
                    skipped += 1
                    continue
                
                success, error_msg = await self.update_company_tax_data(tax_data)
                
                if success:
                    successful += 1
                    print(f"‚úÖ Updated {bin_number} - {company_name}")
                else:
                    failed += 1
                    print(f"‚ùå Failed {bin_number} - {error_msg}")
                    
                    # Log error
                    await self.log_error(bin_number, company_name, "UPDATE_FAILED", error_msg)
            
            # Small delay between batches
            await asyncio.sleep(0.1)
        
        results = {
            'total': total,
            'successful': successful,
            'failed': failed,
            'skipped': skipped
        }
        
        return results
    
    async def log_error(self, bin_number: str, company_name: str, error_type: str, error_message: str):
        """Log import error to CSV file"""
        file_exists = IMPORT_ERRORS_CSV.exists()
        
        with open(IMPORT_ERRORS_CSV, 'a', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=ERROR_FIELDNAMES)
            
            if not file_exists:
                writer.writeheader()
            
            writer.writerow({
                'bin': bin_number,
                'company_name': company_name,
                'error_type': error_type,
                'error_message': error_message,
                'import_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })
    
    async def log_import_results(self, results: Dict[str, int], notes: str = ""):
        """Log import results to CSV file"""
        file_exists = IMPORT_LOG_CSV.exists()
        
        with open(IMPORT_LOG_CSV, 'a', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=LOG_FIELDNAMES)
            
            if not file_exists:
                writer.writeheader()
            
            writer.writerow({
                'import_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                'total_records': results['total'],
                'successful_updates': results['successful'],
                'failed_updates': results['failed'],
                'skipped_records': results['skipped'],
                'notes': notes
            })
    
    async def import_tax_data(self, csv_file: Optional[Path] = None):
        """Main import function"""
        try:
            # Use default CSV file if not specified
            if csv_file is None:
                csv_file = TAX_DATA_CSV
            
            # Connect to database
            await self.connect()
            
            # Ensure tax columns exist
            await self.ensure_tax_columns_exist()
            
            # Load data from CSV
            tax_data_list = await self.load_csv_data(csv_file)
            
            if not tax_data_list:
                print("‚ùå No data to import")
                return
            
            # Perform batch update
            results = await self.batch_update_companies(tax_data_list)
            
            # Log results
            await self.log_import_results(results)
            
            # Print summary
            print(f"\nüéâ Import complete!")
            print(f"üìä Summary:")
            print(f"  Total records: {results['total']}")
            print(f"  ‚úÖ Successful: {results['successful']}")
            print(f"  ‚ùå Failed: {results['failed']}")
            print(f"  ‚è≠Ô∏è  Skipped: {results['skipped']}")
            print(f"üìÅ Logs saved to: {KGD_DATA_DIR}")
            
        except Exception as e:
            print(f"‚ùå Import failed: {e}")
            raise
        finally:
            await self.disconnect()


# Utility functions
async def get_database_stats():
    """Get statistics about tax data in database"""
    importer = KGDDataImporter()
    
    try:
        await importer.connect()
        
        # Get total companies
        total_companies = await importer.connection.fetchval(
            "SELECT COUNT(*) FROM companies"
        )
        
        # Get companies with tax data
        companies_with_tax = await importer.connection.fetchval(
            """
            SELECT COUNT(*) FROM companies 
            WHERE annual_tax_paid IS NOT NULL 
            OR tax_2020 IS NOT NULL 
            OR tax_2021 IS NOT NULL 
            OR tax_2022 IS NOT NULL 
            OR tax_2023 IS NOT NULL 
            OR tax_2024 IS NOT NULL 
            OR tax_2025 IS NOT NULL
            """
        )
        
        # Get companies with recent tax updates
        recent_updates = await importer.connection.fetchval(
            """
            SELECT COUNT(*) FROM companies 
            WHERE last_tax_update >= CURRENT_DATE - INTERVAL '30 days'
            """
        )
        
        print(f"üìä Database Tax Data Statistics:")
        print(f"  Total companies: {total_companies}")
        print(f"  Companies with tax data: {companies_with_tax}")
        print(f"  Companies updated in last 30 days: {recent_updates}")
        print(f"  Coverage: {(companies_with_tax/total_companies*100):.1f}%" if total_companies > 0 else "  Coverage: 0%")
        
    except Exception as e:
        print(f"‚ùå Error getting database stats: {e}")
    finally:
        await importer.disconnect()


async def main():
    """Main function with command line interface"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Import KGD tax data into database")
    parser.add_argument("--csv", type=str, help="Path to CSV file (default: kgd_data/company_tax_data.csv)")
    parser.add_argument("--stats", action="store_true", help="Show database statistics")
    parser.add_argument("--test", action="store_true", help="Test database connection")
    
    args = parser.parse_args()
    
    if args.stats:
        await get_database_stats()
        return
    
    if args.test:
        importer = KGDDataImporter()
        try:
            await importer.connect()
            print("‚úÖ Database connection successful")
        except Exception as e:
            print(f"‚ùå Database connection failed: {e}")
        finally:
            await importer.disconnect()
        return
    
    # Import data
    csv_file = Path(args.csv) if args.csv else None
    importer = KGDDataImporter()
    await importer.import_tax_data(csv_file)


if __name__ == "__main__":
    asyncio.run(main()) 