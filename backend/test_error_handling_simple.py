#!/usr/bin/env python3
"""
Simple test script for the error handling improvements.
Tests only the core logic without database dependencies.
"""

import time
import re
from typing import Optional, List, Dict, Any

class MockGeminiService:
    """Mock service for testing error handling logic."""
    
    def __init__(self):
        # Circuit breaker state
        self._circuit_breaker_failures = 0
        self._circuit_breaker_last_failure_time = 0
        self._circuit_breaker_threshold = 5  # failures before opening
        self._circuit_breaker_timeout = 60  # seconds to wait before trying again
        self._circuit_breaker_state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN

    def _should_use_circuit_breaker(self) -> bool:
        """
        Check if circuit breaker should prevent API calls.
        """
        current_time = time.time()
        
        if self._circuit_breaker_state == "OPEN":
            if current_time - self._circuit_breaker_last_failure_time > self._circuit_breaker_timeout:
                print("üîÑ [CIRCUIT_BREAKER] Moving to HALF_OPEN state")
                self._circuit_breaker_state = "HALF_OPEN"
                return False
            else:
                print("üö´ [CIRCUIT_BREAKER] Circuit breaker is OPEN, skipping API call")
                return True
        
        return False

    def _record_circuit_breaker_failure(self):
        """
        Record a failure for circuit breaker logic.
        """
        self._circuit_breaker_failures += 1
        self._circuit_breaker_last_failure_time = time.time()
        
        if self._circuit_breaker_failures >= self._circuit_breaker_threshold:
            print(f"üö´ [CIRCUIT_BREAKER] Opening circuit breaker after {self._circuit_breaker_failures} failures")
            self._circuit_breaker_state = "OPEN"
        else:
            print(f"‚ö†Ô∏è [CIRCUIT_BREAKER] Failure {self._circuit_breaker_failures}/{self._circuit_breaker_threshold}")

    def _record_circuit_breaker_success(self):
        """
        Record a success for circuit breaker logic.
        """
        if self._circuit_breaker_state == "HALF_OPEN":
            print("‚úÖ [CIRCUIT_BREAKER] Success in HALF_OPEN state, closing circuit breaker")
            self._circuit_breaker_state = "CLOSED"
        
        self._circuit_breaker_failures = 0

    def get_service_status(self) -> Dict[str, Any]:
        """
        Get current service status including circuit breaker state.
        """
        return {
            "circuit_breaker_state": self._circuit_breaker_state,
            "circuit_breaker_failures": self._circuit_breaker_failures,
            "circuit_breaker_threshold": self._circuit_breaker_threshold,
            "last_failure_time": self._circuit_breaker_last_failure_time,
            "time_since_last_failure": time.time() - self._circuit_breaker_last_failure_time if self._circuit_breaker_last_failure_time > 0 else None
        }

    def reset_circuit_breaker(self):
        """
        Manually reset the circuit breaker to CLOSED state.
        """
        print("üîÑ [CIRCUIT_BREAKER] Manually resetting circuit breaker")
        self._circuit_breaker_state = "CLOSED"
        self._circuit_breaker_failures = 0
        self._circuit_breaker_last_failure_time = 0

    def _extract_location_fallback(self, message: str) -> Optional[str]:
        """Simple location extraction as fallback when Gemini is unavailable."""
        # Common location keywords with variations
        location_mappings = {
            "–∞–ª–º–∞—Ç—ã": "–ê–ª–º–∞—Ç—ã",
            "–∞—Å—Ç–∞–Ω–∞": "–ê—Å—Ç–∞–Ω–∞", 
            "–∞—Å—Ç–∞–Ω–µ": "–ê—Å—Ç–∞–Ω–∞",
            "—à—ã–º–∫–µ–Ω—Ç": "–®—ã–º–∫–µ–Ω—Ç",
            "–∞–∫—Ç–æ–±–µ": "–ê–∫—Ç–æ–±–µ",
            "–∫–∞—Ä–∞–≥–∞–Ω–¥–∞": "–ö–∞—Ä–∞–≥–∞–Ω–¥–∞",
            "–∫–∞—Ä–∞–≥–∞–Ω–¥–µ": "–ö–∞—Ä–∞–≥–∞–Ω–¥–∞",
            "—Ç–∞—Ä–∞–∑": "–¢–∞—Ä–∞–∑",
            "–ø–∞–≤–ª–æ–¥–∞—Ä": "–ü–∞–≤–ª–æ–¥–∞—Ä",
            "—Å–µ–º–µ–π": "–°–µ–º–µ–π",
            "—É—Å—Ç—å-–∫–∞–º–µ–Ω–æ–≥–æ—Ä—Å–∫": "–£—Å—Ç—å-–ö–∞–º–µ–Ω–æ–≥–æ—Ä—Å–∫",
            "—É—Ä–¥–∂–∞—Ä": "–£—Ä–¥–∂–∞—Ä",
            "–∫—ã–∑—ã–ª–æ—Ä–¥–∞": "–ö—ã–∑—ã–ª–æ—Ä–¥–∞",
            "–∞—Ç—ã—Ä–∞—É": "–ê—Ç—ã—Ä–∞—É",
            "–∞–∫—Ç–∞—É": "–ê–∫—Ç–∞—É",
            "–∫–æ—Å—Ç–∞–Ω–∞–π": "–ö–æ—Å—Ç–∞–Ω–∞–π",
            "–ø–µ—Ç—Ä–æ–ø–∞–≤–ª–æ–≤—Å–∫": "–ü–µ—Ç—Ä–æ–ø–∞–≤–ª–æ–≤—Å–∫",
            "–∫–æ–∫—à–µ—Ç–∞—É": "–ö–æ–∫—à–µ—Ç–∞—É",
            "—Ç–∞–ª–¥—ã–∫–æ—Ä–≥–∞–Ω": "–¢–∞–ª–¥—ã–∫–æ—Ä–≥–∞–Ω",
            "—Ç—É—Ä–∫–µ—Å—Ç–∞–Ω": "–¢—É—Ä–∫–µ—Å—Ç–∞–Ω",
            "–∫–µ–Ω—Ç–∞—É": "–ö–µ–Ω—Ç–∞—É",
            "–∂–∞–º–±—ã–ª": "–ñ–∞–º–±—ã–ª"
        }
        
        message_lower = message.lower()
        for location_variant, canonical_name in location_mappings.items():
            if location_variant in message_lower:
                return canonical_name
        return None

    def _extract_quantity_fallback(self, message: str) -> int:
        """Simple quantity extraction as fallback when Gemini is unavailable."""
        numbers = re.findall(r'\d+', message)
        if numbers:
            return min(int(numbers[0]), 50)  # Cap at 50 for safety
        return 10

    def _extract_activity_fallback(self, message: str) -> Optional[List[str]]:
        """Simple activity keyword extraction as fallback when Gemini is unavailable."""
        # Common activity keywords with variations
        activity_mappings = {
            "it": "IT",
            "—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏": "—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏",
            "—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è": "—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏",
            "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ": "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ",
            "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç": "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ",
            "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ": "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ",
            "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–π": "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ",
            "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ": "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ",
            "—Ç–æ—Ä–≥–æ–≤–ª—è": "—Ç–æ—Ä–≥–æ–≤–ª—è",
            "—Ç–æ—Ä–≥–æ–≤—ã–π": "—Ç–æ—Ä–≥–æ–≤–ª—è",
            "–ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ": "–ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ",
            "–ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω—ã–π": "–ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–æ",
            "—É—Å–ª—É–≥–∏": "—É—Å–ª—É–≥–∏",
            "—É—Å–ª—É–≥–∞": "—É—Å–ª—É–≥–∏",
            "–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ": "–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
            "–æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π": "–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
            "–º–µ–¥–∏—Ü–∏–Ω–∞": "–º–µ–¥–∏—Ü–∏–Ω–∞",
            "–º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–π": "–º–µ–¥–∏—Ü–∏–Ω–∞",
            "–º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–µ": "–º–µ–¥–∏—Ü–∏–Ω–∞",
            "—Ñ–∏–Ω–∞–Ω—Å—ã": "—Ñ–∏–Ω–∞–Ω—Å—ã",
            "—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–π": "—Ñ–∏–Ω–∞–Ω—Å—ã",
            "—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ": "—Ñ–∏–Ω–∞–Ω—Å—ã",
            "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç": "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç",
            "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã–π": "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç",
            "—ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∞": "—ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∞",
            "—ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–π": "—ç–Ω–µ—Ä–≥–µ—Ç–∏–∫–∞",
            "–Ω–µ—Ñ—Ç—å": "–Ω–µ—Ñ—Ç—å",
            "–Ω–µ—Ñ—Ç—è–Ω–æ–π": "–Ω–µ—Ñ—Ç—å",
            "–Ω–µ—Ñ—Ç—è–Ω—ã–µ": "–Ω–µ—Ñ—Ç—å",
            "–≥–∞–∑": "–≥–∞–∑",
            "–≥–∞–∑–æ–≤—ã–π": "–≥–∞–∑",
            "–º–µ—Ç–∞–ª–ª—É—Ä–≥–∏—è": "–º–µ—Ç–∞–ª–ª—É—Ä–≥–∏—è",
            "–º–µ—Ç–∞–ª–ª—É—Ä–≥–∏—á–µ—Å–∫–∏–π": "–º–µ—Ç–∞–ª–ª—É—Ä–≥–∏—è"
        }
        
        message_lower = message.lower()
        found_keywords = []
        for keyword_variant, canonical_keyword in activity_mappings.items():
            if keyword_variant in message_lower:
                if canonical_keyword not in found_keywords:
                    found_keywords.append(canonical_keyword)
        
        return found_keywords if found_keywords else None

    def _get_fallback_message(self, error_type: str) -> str:
        """Get appropriate fallback message based on error type."""
        messages = {
            "timeout": "–ò–∑–≤–∏–Ω–∏—Ç–µ, –∑–∞–ø—Ä–æ—Å –∑–∞–Ω–∏–º–∞–µ—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏, —á–µ–º –æ–∂–∏–¥–∞–ª–æ—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.",
            "http_error": "–ò–∑–≤–∏–Ω–∏—Ç–µ, —É –Ω–∞—Å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
            "json_error": "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–≤–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å.",
            "unexpected_error": "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
            "max_retries_exceeded": "–ò–∑–≤–∏–Ω–∏—Ç–µ, —Å–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            "service_unavailable": "–ò–∑–≤–∏–Ω–∏—Ç–µ, —Å–µ—Ä–≤–∏—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç.",
            "circuit_breaker_open": "–ò–∑–≤–∏–Ω–∏—Ç–µ, —Å–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–∑-–∑–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É."
        }
        return messages.get(error_type, "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")

def test_circuit_breaker():
    """Test the circuit breaker functionality."""
    print("üß™ Testing Circuit Breaker Functionality")
    print("=" * 50)
    
    service = MockGeminiService()
    
    # Test initial state
    print("1. Testing initial state...")
    status = service.get_service_status()
    print(f"   Circuit breaker state: {status['circuit_breaker_state']}")
    print(f"   Failures: {status['circuit_breaker_failures']}")
    assert status['circuit_breaker_state'] == 'CLOSED'
    print("   ‚úÖ Initial state is correct")
    
    # Test recording failures
    print("\n2. Testing failure recording...")
    for i in range(3):
        service._record_circuit_breaker_failure()
        status = service.get_service_status()
        print(f"   After {i+1} failures: {status['circuit_breaker_failures']}/{status['circuit_breaker_threshold']}")
    
    assert status['circuit_breaker_state'] == 'CLOSED'  # Should still be closed
    print("   ‚úÖ Circuit breaker still closed after 3 failures")
    
    # Test opening circuit breaker
    print("\n3. Testing circuit breaker opening...")
    for i in range(2):  # Add 2 more failures to reach threshold
        service._record_circuit_breaker_failure()
    
    status = service.get_service_status()
    print(f"   After 5 failures: {status['circuit_breaker_failures']}/{status['circuit_breaker_threshold']}")
    print(f"   Circuit breaker state: {status['circuit_breaker_state']}")
    assert status['circuit_breaker_state'] == 'OPEN'
    print("   ‚úÖ Circuit breaker opened correctly")
    
    # Test reset
    print("\n4. Testing circuit breaker reset...")
    service.reset_circuit_breaker()
    status = service.get_service_status()
    print(f"   After reset: {status['circuit_breaker_state']}")
    assert status['circuit_breaker_state'] == 'CLOSED'
    print("   ‚úÖ Circuit breaker reset correctly")

def test_fallback_parsing():
    """Test the fallback parsing functionality."""
    print("\nüß™ Testing Fallback Parsing")
    print("=" * 50)
    
    service = MockGeminiService()
    
    # Test location extraction
    print("1. Testing location extraction...")
    test_messages = [
        "–ù–∞–π–¥–∏ –∫–æ–º–ø–∞–Ω–∏–∏ –≤ –ê–ª–º–∞—Ç—ã",
        "–ü–æ–∫–∞–∂–∏ —Ñ–∏—Ä–º—ã –≤ –ê—Å—Ç–∞–Ω–µ",
        "–ò—â—É –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è –≤ –ö–∞—Ä–∞–≥–∞–Ω–¥–µ",
        "–°—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏—Ä–º—ã –≤ –ê—Å—Ç–∞–Ω–µ",
        "–ù–µ—Ç –ª–æ–∫–∞—Ü–∏–∏ –≤ —ç—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏"
    ]
    
    for message in test_messages:
        location = service._extract_location_fallback(message)
        print(f"   '{message}' -> {location}")
    
    # Test quantity extraction
    print("\n2. Testing quantity extraction...")
    test_messages = [
        "–ù–∞–π–¥–∏ 15 –∫–æ–º–ø–∞–Ω–∏–π",
        "–ü–æ–∫–∞–∂–∏ 25 —Ñ–∏—Ä–º",
        "–ò—â—É 100 –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–π",  # Should be capped at 50
        "–ù–µ—Ç —á–∏—Å–ª–∞ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏"
    ]
    
    for message in test_messages:
        quantity = service._extract_quantity_fallback(message)
        print(f"   '{message}' -> {quantity}")
    
    # Test activity extraction
    print("\n3. Testing activity extraction...")
    test_messages = [
        "IT –∫–æ–º–ø–∞–Ω–∏–∏ –≤ –ê–ª–º–∞—Ç—ã",
        "–°—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏—Ä–º—ã",
        "–§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —É—Å–ª—É–≥–∏",
        "–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–µ —É—Å–ª—É–≥–∏",
        "–ù–µ—Ñ—Ç—è–Ω—ã–µ –∫–æ–º–ø–∞–Ω–∏–∏",
        "–û–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤"
    ]
    
    for message in test_messages:
        activities = service._extract_activity_fallback(message)
        print(f"   '{message}' -> {activities}")

def test_fallback_messages():
    """Test the fallback message generation."""
    print("\nüß™ Testing Fallback Messages")
    print("=" * 50)
    
    service = MockGeminiService()
    
    error_types = [
        "timeout",
        "http_error", 
        "json_error",
        "circuit_breaker_open",
        "service_unavailable",
        "unknown_error"
    ]
    
    for error_type in error_types:
        message = service._get_fallback_message(error_type)
        print(f"   {error_type}: {message[:50]}...")

def main():
    """Run all tests."""
    print("üöÄ Starting Error Handling Tests")
    print("=" * 60)
    
    try:
        # Test circuit breaker
        test_circuit_breaker()
        
        # Test fallback parsing
        test_fallback_parsing()
        
        # Test fallback messages
        test_fallback_messages()
        
        print("\n" + "=" * 60)
        print("‚úÖ All tests passed successfully!")
        print("=" * 60)
        
    except Exception as e:
        print(f"\n‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    return True

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1) 